<!DOCTYPE html>
<html lang="pl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Galeria: {{ current_folder_display_name }}</title>
    <!-- 
      ####################################################################
      #  TUTAJ JEST KLUCZOWA POPRAWKA:                                   #
      #  Zamiast "{{ ' ../' * depth }}gallery_styles.css"               #
      #  UÅ¼ywamy "{{ css_path_prefix }}gallery_styles.css"              #
      #  css_path_prefix jest przekazywane z gallery_generator.py       #
      #  i jest albo "" (dla roota) albo "../" (dla podfolderÃ³w)        #
      ####################################################################
    -->
    <link rel="stylesheet" href="{{ css_path_prefix }}gallery_styles.css" />
  </head>
  <body>
    <div class="container">
      <!-- TYLKO BREADCRUMB - Å›cieÅ¼ka -->
      <div class="breadcrumb">
        {% for part in breadcrumb_parts %} {% if part.link %}
        <a href="{{ part.link }}">{{ part.name }}</a>
        {% else %}
        <span>{{ part.name }}</span>
        {% endif %} {% if not loop.last %} {# Dodaj separator, jeÅ›li to nie
        ostatni element #}
        <span>/</span>
        {% endif %} {% endfor %}
      </div>

      {% if subfolders %}
      <div class="section">
        <h2>ğŸ“ Podfoldery ({{ subfolders|length }})</h2>
        <div class="subfolders-grid">
          {% for sf in subfolders %}
          <div
            class="subfolder-item"
            onclick="window.location.href='{{ sf.link }}'"
          >
            <div class="folder-icon" data-archive-count="{{ sf.file_count }}">
              ğŸ“
            </div>
            <a href="{{ sf.link }}">{{ sf.name }}</a>
            <div class="folder-stats">
              <span
                >{{ sf.total_size_readable }} | {{ sf.file_count }} plikÃ³w{% if
                sf.subdir_count > 0 %} | {{ sf.subdir_count }} folderÃ³w{% endif
                %}</span
              >
            </div>
          </div>
          {% endfor %}
        </div>
      </div>
      {% elif not files_with_previews and not other_images and not
      is_root_gallery_index %} {# JeÅ›li nie ma podfolderÃ³w, plikÃ³w z podglÄ…dem,
      innych obrazÃ³w, i nie jesteÅ›my w roocie, to znaczy, Å¼e jesteÅ›my w liÅ›ciu
      drzewa, ktÃ³ry jest pusty - moÅ¼na to obsÅ‚uÅ¼yÄ‡ inaczej, ale jeÅ›li taki
      folder ma index.json to powinien wyÅ›wietliÄ‡ coÅ›. JeÅ›li nie ma subfolderÃ³w,
      a jesteÅ›my w roocie, to JS/Python moÅ¼e chcieÄ‡ wyÅ›wietliÄ‡ info. Ten warunek
      jest trochÄ™ skomplikowany - moÅ¼e proÅ›ciej wyÅ›wietliÄ‡ poniÅ¼sze jeÅ›li nic
      innego nie ma. #} {% endif %} {% if files_with_previews %}
      <div class="section">
        <h2>ğŸ–¼ï¸ Pliki z podglÄ…dem ({{ files_with_previews|length }})</h2>
        <div class="gallery" id="filesWithPreviewsGallery">
          {% for file in files_with_previews %}
          <div
            class="gallery-item"
            style="background-color: {{ file.archive_color if file.archive_color else 'transparent' }}22; border-color: {{ file.archive_color if file.archive_color else 'var(--border)' }};"
          >
            <input
              type="checkbox"
              class="gallery-checkbox"
              data-file="{{ file.name }}"
              data-path="{{ file.path_absolute }}"
              data-type="archive"
            />
            {% if file.preview_relative_path %}
            <img
              src="{{ file.preview_relative_path }}"
              alt="PodglÄ…d dla {{ file.name }}"
              class="preview-image"
              data-full-src="{{ file.preview_relative_path }}"
            />
            {% else %}
            <div
              style="
                height: 160px;
                background: var(--bg-primary);
                display: flex;
                align-items: center;
                justify-content: center;
                border-radius: var(--radius-sm);
                color: var(--text-secondary);
              "
            >
              <span>Brak podglÄ…du</span>
            </div>
            {% endif %}
            <p>
              <a href="{{ file.archive_link }}" title="OtwÃ³rz: {{ file.name }}"
                >{{ file.name }}</a
              >
            </p>
            <p class="file-info">{{ file.size_readable }}</p>
          </div>
          {% endfor %}
        </div>
      </div>
      {% endif %} {% if files_without_previews or other_images %}
      <div class="bottom-columns">
        {% if files_without_previews %}
        <div class="left-column">
          <h2>ğŸ“„ Pliki bez podglÄ…du ({{ files_without_previews|length }})</h2>
          {% if files_without_previews %}
          <ul class="no-preview-list">
            {% for file in files_without_previews %}
            <li
              style="border-left: 4px solid {{ file.archive_color if file.archive_color else 'transparent' }};"
            >
              <div class="file-item">
                <input
                  type="checkbox"
                  class="file-checkbox"
                  data-file="{{ file.name }}"
                  data-path="{{ file.path_absolute }}"
                  data-basename="{{ file.name.split('.')[0] if '.' in file.name else file.name }}"
                  data-type="archive"
                />
                <a
                  href="{{ file.archive_link }}"
                  title="OtwÃ³rz: {{ file.name }}"
                  >{{ file.name }}</a
                >
                <span class="file-info"> â€” {{ file.size_readable }}</span>
              </div>
            </li>
            {% endfor %}
          </ul>
          {% else %}
          <p>Brak plikÃ³w bez podglÄ…du.</p>
          {% endif %}
        </div>
        {% endif %} {% if other_images %}
        <div class="right-column">
          <h2>ğŸ¨ PozostaÅ‚e obrazy ({{ other_images|length }})</h2>
          {% if other_images %}
          <ul class="image-list">
            {% for image in other_images %}
            <li>
              <div class="file-item">
                <input
                  type="checkbox"
                  class="file-checkbox"
                  data-file="{{ image.name }}"
                  data-path="{{ image.path_absolute }}"
                  data-basename="{{ image.name.split('.')[0] if '.' in image.name else image.name }}"
                  data-type="image"
                />
                <a
                  href="{{ image.file_link }}"
                  title="OtwÃ³rz: {{ image.name }}"
                  data-preview-src="{{ image.image_relative_path }}"
                  class="preview-link"
                  >{{ image.name }}</a
                >
                <span class="file-info"> â€” {{ image.size_readable }}</span>
                <button
                  class="delete-image-btn"
                  data-file-path="{{ image.path_absolute }}"
                  data-file-name="{{ image.name }}"
                  title="UsuÅ„ {{ image.name }} do kosza"
                >
                  ğŸ—‘ï¸
                </button>
              </div>
            </li>
            {% endfor %}
          </ul>
          {% else %}
          <p>Brak innych obrazÃ³w.</p>
          {% endif %}
        </div>
        {% endif %}
      </div>
      {% elif not subfolders and not files_with_previews and not
      files_without_previews and not other_images %}
      <div class="section">
        <p>
          Ten folder jest pusty lub nie zawiera elementÃ³w do wyÅ›wietlenia w
          galerii.
        </p>
      </div>
      {% endif %} {% if (files_without_previews and other_images) or
      (files_with_previews and other_images) or (files_with_previews and
      files_without_previews) %}
      <div class="learning-section">
        <button id="matchPreviewBtn" class="match-preview-btn" disabled>
          ğŸ¯ Dopasuj podglÄ…d
        </button>
        <div id="matchStatus" class="match-status"></div>
      </div>
      {% endif %}
    </div>

    <div class="preview-backdrop" id="previewBackdrop"></div>
    <div class="preview-modal" id="previewModal">
      <img src="" alt="PodglÄ…d" id="previewImg" />
    </div>

    <script>
      // Przekazanie danych z Pythona do JS dla wiÄ™kszej niezawodnoÅ›ci
      // Upewnij siÄ™, Å¼e `folder_info` zawiera `path_absolute`
      window.galleryConfig = {
          currentFolderAbsPath: {{ folder_info.path_absolute | tojson | safe if folder_info and folder_info.path_absolute else 'null' }},
          isRootIndex: {{ is_root_gallery_index | tojson | safe }},
          scannedRootPath: {{ scanned_root_path_abs_for_template | tojson | safe }}
      };

      console.log("Gallery Config from Python:", window.galleryConfig);

      function getCurrentFolder() {
        if (window.galleryConfig && window.galleryConfig.currentFolderAbsPath) {
            return window.galleryConfig.currentFolderAbsPath.replace(/\\/g, '/');
        }
        console.warn("getCurrentFolder: Fallback, window.galleryConfig.currentFolderAbsPath not available.");
        // Ten fallback jest mniej idealny, ale jako zabezpieczenie
        const fallbackPath = {{ folder_info.path_absolute | tojson | safe if folder_info and folder_info.path_absolute else "'.'".format() }};
        return fallbackPath.replace(/\\/g, '/');
      }
      window.getCurrentFolder = getCurrentFolder;

      document.addEventListener('DOMContentLoaded', function () {
        const galleries = [
          document.getElementById('filesWithPreviewsGallery'),
        ].filter(Boolean);

        const previewModal = document.getElementById('previewModal');
        const previewBackdrop = document.getElementById('previewBackdrop');
        const previewImg = document.getElementById('previewImg');
        const matchBtn = document.getElementById('matchPreviewBtn');
        const matchStatus = document.getElementById('matchStatus');

        function showPreview(imageSrc) {
          if (!imageSrc) return;
          previewImg.src = imageSrc;
          previewModal.classList.add('show');
          previewBackdrop.classList.add('show');
        }

        function hidePreview() {
          previewModal.classList.remove('show');
          previewBackdrop.classList.remove('show');
          previewImg.src = '';
        }

        const deleteButtons = document.querySelectorAll('.delete-image-btn');
        deleteButtons.forEach((button) => {
          button.addEventListener('click', function (e) {
            e.preventDefault(); e.stopPropagation();
            const filePath = this.dataset.filePath;
            const fileName = this.dataset.fileName;
            if (confirm(`Czy na pewno chcesz usunÄ…Ä‡ plik "${fileName}" do kosza?`)) {
              try {
                if (typeof Storage === 'undefined' || !localStorage) { alert('Funkcja usuwania nie jest dostÄ™pna.'); return; }
                const deleteData = { action: 'deleteFile', filePath: filePath, fileName: fileName, timestamp: new Date().toISOString() };
                console.log('ğŸ—‘ï¸ Usuwanie pliku:', deleteData);
                const deleteKey = 'deleteFile_' + Date.now();
                localStorage.setItem(deleteKey, JSON.stringify(deleteData));
                localStorage.setItem('latestDelete', deleteKey);
                this.textContent = 'â³'; this.disabled = true; this.style.opacity = '0.5';
                const statusDiv = document.createElement('div');
                statusDiv.className = 'file-operation-notification warning';
                statusDiv.textContent = `â³ Usuwanie "${fileName}"...`;
                document.body.appendChild(statusDiv);
                setTimeout(() => { if (statusDiv.parentNode) statusDiv.parentNode.removeChild(statusDiv); }, 5000);
              } catch (err) { console.error('BÅ‚Ä…d usuwania pliku:', err); alert('WystÄ…piÅ‚ bÅ‚Ä…d podczas usuwania.'); }
            }
          });
        });

        galleries.forEach((gallery) => {
          const images = gallery.querySelectorAll('.preview-image');
          images.forEach((img) => {
            let hoverTimeout;
            img.addEventListener('mouseenter', function () { hoverTimeout = setTimeout(() => { showPreview(this.src); }, 1000); });
            img.addEventListener('mouseleave', function () { clearTimeout(hoverTimeout); });
          });
        });

        const previewLinks = document.querySelectorAll('.preview-link');
        previewLinks.forEach((link) => {
          let hoverTimeout;
          link.addEventListener('mouseenter', function () {
            const previewSrc = this.getAttribute('data-preview-src');
            if (previewSrc) { hoverTimeout = setTimeout(() => { showPreview(previewSrc); }, 1000); }
          });
          link.addEventListener('mouseleave', function () { clearTimeout(hoverTimeout); });
        });

        previewBackdrop.addEventListener('click', hidePreview);
        previewModal.addEventListener('click', (e) => { if(e.target === previewModal) hidePreview(); });
        document.addEventListener('keydown', function (e) { if (e.key === 'Escape') hidePreview(); });

        if (matchBtn) {
          let localStorageAvailable = false;
          try {
              if (typeof Storage !== 'undefined' && localStorage) {
                  localStorage.setItem('test','test');
                  localStorage.removeItem('test');
                  localStorageAvailable = true;
              }
          } catch (e) {
              console.warn('localStorage nie jest dostÄ™pny:', e);
          }

          if (!localStorageAvailable) {
              matchBtn.style.display = 'none';
              if(matchStatus) matchStatus.textContent = 'âš ï¸ Funkcje uczenia niedostÄ™pne.';
              return;
          }

          const checkboxes = document.querySelectorAll('.file-checkbox, .gallery-checkbox');

          function updateMatchButton() {
              const archiveChecked = Array.from(checkboxes).filter(cb => {
                  return cb.checked && (cb.dataset.type === 'archive' || cb.classList.contains('gallery-checkbox'));
              });
              const imageChecked = Array.from(checkboxes).filter(cb => {
                  return cb.checked && cb.dataset.type === 'image';
              });

              const canMatch = archiveChecked.length === 1 && imageChecked.length === 1;
              matchBtn.disabled = !canMatch;

              if (matchStatus) {
                  if (canMatch) {
                      const archiveName = archiveChecked[0].dataset.file;
                      const imageName = imageChecked[0].dataset.file;
                      matchStatus.textContent = `Gotowy: ${archiveName} â†” ${imageName}`;
                  } else if (archiveChecked.length === 0 && imageChecked.length === 0) {
                      matchStatus.textContent = 'Zaznacz 1 archiwum i 1 obraz';
                  } else if (archiveChecked.length === 0) {
                      matchStatus.textContent = 'Zaznacz 1 archiwum';
                  } else if (imageChecked.length === 0) {
                      matchStatus.textContent = 'Zaznacz 1 obraz';
                  } else {
                      matchStatus.textContent = 'Zaznacz tylko 1 archiwum i 1 obraz';
                  }
              }
          }

          checkboxes.forEach((checkbox) => {
              checkbox.addEventListener('change', function () {
                  if (this.checked) {
                      const currentType = this.dataset.type || (this.classList.contains('gallery-checkbox') ? 'archive' : 'unknown');
                      // Odznacz inne checkboxy tego samego typu
                      checkboxes.forEach((otherCb) => {
                          if (otherCb !== this) {
                              const otherType = otherCb.dataset.type || (otherCb.classList.contains('gallery-checkbox') ? 'archive' : 'unknown');
                              if (otherType === currentType) {
                                  otherCb.checked = false;
                              }
                          }
                      });
                  }
                  updateMatchButton();
              });
          });

          matchBtn.addEventListener('click', function () {
              const archiveCb = Array.from(checkboxes).find(cb => {
                  return cb.checked && (cb.dataset.type === 'archive' || cb.classList.contains('gallery-checkbox'));
              });
              const imageCb = Array.from(checkboxes).find(cb => {
                  return cb.checked && cb.dataset.type === 'image';
              });

              if (archiveCb && imageCb) {
                  // Pobierz basename z nazwy pliku
                  const getBasename = (filename) => {
                      const lastDotIndex = filename.lastIndexOf('.');
                      return lastDotIndex > 0 ? filename.substring(0, lastDotIndex) : filename;
                  };

                  const matchData = {
                      archiveFile: archiveCb.dataset.file,
                      archivePath: archiveCb.dataset.path.replace(/\\/g, '/'),
                      imageFile: imageCb.dataset.file,
                      imagePath: imageCb.dataset.path.replace(/\\/g, '/'),
                      archiveBasename: getBasename(archiveCb.dataset.file),
                      imageBasename: getBasename(imageCb.dataset.file),
                      timestamp: new Date().toISOString(),
                      currentFolder: getCurrentFolder()
                  };

                  console.log('ğŸ¯ ZapisujÄ™ dopasowanie:', matchData);

                  const matchKey = 'learningMatch_' + Date.now();
                  localStorage.setItem(matchKey, JSON.stringify(matchData));
                  localStorage.setItem('latestLearningMatch', matchKey);

                  if(matchStatus) matchStatus.textContent = 'âœ… Zapisano! Nauka algorytmu...';
                  matchBtn.disabled = true;
                  matchBtn.textContent = 'â³ Przetwarzanie...';

                  // Odznacz checkboxy
                  archiveCb.checked = false;
                  imageCb.checked = false;

                  // PrzywrÃ³Ä‡ stan przycisku po 3 sekundach
                  setTimeout(() => {
                      matchBtn.disabled = false;
                      matchBtn.textContent = 'ğŸ¯ Dopasuj podglÄ…d';
                      if(matchStatus) matchStatus.textContent = '';
                  }, 3000);
              }
          });

          // Inicjalne sprawdzenie
          updateMatchButton();
        }

        // Logika dla przywracania rozmiaru kafelkÃ³w z localStorage (jeÅ›li suwak jest w Pythonie)
        // MoÅ¼esz jÄ… usunÄ…Ä‡, jeÅ›li rozmiar kafelkÃ³w jest zarzÄ…dzany tylko przez suwak w UI Pythona
        if (typeof localStorage !== 'undefined' && localStorage.getItem('galleryTileSize')) {
            const savedSize = localStorage.getItem('galleryTileSize');
            const galleriesToResize = document.querySelectorAll('.gallery');
            galleriesToResize.forEach(gallery => {
                gallery.style.gridTemplateColumns = `repeat(auto-fill, minmax(${savedSize}px, 1fr))`;
            });
        }

        // PoniÅ¼sze funkcje (showMoveFilesDialog itp.) sÄ… definicjami,
        // ale nie sÄ… wywoÅ‚ywane bezpoÅ›rednio z HTML.
        // SÄ… one dostÄ™pne dla Pythona do wywoÅ‚ania poprzez webView.page().runJavaScript("showMoveFilesDialog();")
        // jeÅ›li przyciski byÅ‚yby w HTML. W Twoim przypadku przyciski sÄ… w Pythonie,
        // wiÄ™c ta czÄ™Å›Ä‡ jest bardziej "bibliotekÄ…" funkcji dla localStorage.

        let selectedFiles = []; // Zmienna globalna w tym zakresie DOMContentLoaded

        function updateSelectedFiles() {
          selectedFiles = [];
          document.querySelectorAll('.gallery-checkbox:checked').forEach(cb => {
            selectedFiles.push({ type: 'archive_with_preview', name: cb.dataset.file, path: cb.dataset.path, preview: cb.closest('.gallery-item').querySelector('img')?.src || null });
          });
          document.querySelectorAll('.file-checkbox:checked[data-type="archive"]').forEach(cb => {
            selectedFiles.push({ type: 'archive', name: cb.dataset.file, path: cb.dataset.path, basename: cb.dataset.basename });
          });
          document.querySelectorAll('.file-checkbox:checked[data-type="image"]').forEach(cb => {
            selectedFiles.push({ type: 'image', name: cb.dataset.file, path: cb.dataset.path, basename: cb.dataset.basename });
          });
          console.log('JS: Wybrane pliki:', selectedFiles);
        }

        // Te funkcje zapisujÄ… dane do localStorage, Python je odczytuje
        window.jsShowMoveFilesDialog = function() { // Zmieniono nazwÄ™, aby uniknÄ…Ä‡ konfliktu
          updateSelectedFiles();
          if (selectedFiles.length === 0) { alert('Najpierw zaznacz pliki do przeniesienia'); return; }
          const moveData = { files: selectedFiles };
          const moveKey = 'moveFiles_' + Date.now();
          localStorage.setItem(moveKey, JSON.stringify(moveData));
          localStorage.setItem('latestMoveFiles', moveKey);
          document.querySelectorAll('.gallery-checkbox, .file-checkbox').forEach(cb => { cb.checked = false; });
          console.log('JS: Zapisano operacjÄ™ przenoszenia:', moveData);
        }

        window.jsShowRenameFilesDialog = function() { // Zmieniono nazwÄ™
          updateSelectedFiles();
          if (selectedFiles.length === 0) { alert('Najpierw zaznacz pliki do zmiany nazwy'); return; }
          const archiveFiles = selectedFiles.filter(f => f.type === 'archive' || f.type === 'archive_with_preview');
          const imageFiles = selectedFiles.filter(f => f.type === 'image');
          // Zamiast prompt, Python zapyta o nowÄ… nazwÄ™
          // Tutaj tylko przygotowujemy dane
          if (archiveFiles.length > 0 || imageFiles.length > 0) { // Wystarczy, Å¼e coÅ› jest zaznaczone
              const renameData = { files: selectedFiles, /* newBaseName zostanie dodane przez Pythona */ };
              const renameKey = 'renameFiles_' + Date.now();
              localStorage.setItem(renameKey, JSON.stringify(renameData));
              localStorage.setItem('latestRenameFilesRequest', renameKey); // Inny klucz dla Å¼Ä…dania
              document.querySelectorAll('.gallery-checkbox, .file-checkbox').forEach(cb => { cb.checked = false; });
              console.log('JS: Zapisano Å¼Ä…danie zmiany nazw:', renameData);
          } else {
            alert('Zaznacz pliki, aby zmieniÄ‡ ich nazwy.');
          }
        }

        window.jsShowCreateFolderDialog = function() { // Zmieniono nazwÄ™
          const folderName = prompt('Podaj nazwÄ™ nowego folderu:'); // JS moÅ¼e zapytaÄ‡, albo Python
          if (folderName && folder_name.trim()) { // UÅ¼yj folder_name z prompt
            const invalidChars = /[<>:"/\\|?*]/;
            if (invalidChars.test(folder_name.trim())) {
              alert(`Nazwa folderu zawiera niedozwolone znaki: ${invalidChars.source}`); return;
            }
            const createData = { parentFolder: getCurrentFolder(), folderName: folder_name.trim() };
            const createKey = 'createFolder_' + Date.now();
            localStorage.setItem(createKey, JSON.stringify(createData));
            localStorage.setItem('latestCreateFolder', createKey);
            console.log('JS: Zapisano operacjÄ™ tworzenia folderu:', createData);
          }
        }

        // Listener dla checkboxÃ³w, aby aktualizowaÄ‡ `selectedFiles`
        document.addEventListener('change', function (e) {
          if (e.target.matches('.gallery-checkbox, .file-checkbox')) {
            updateSelectedFiles(); // Aktualizuj przy kaÅ¼dej zmianie zaznaczenia
          }
        });

      });
    </script>
  </body>
</html>
